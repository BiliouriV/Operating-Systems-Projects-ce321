DIMITRIS CHRISTODOULOU	AEM 2113 	dchristodoulou@uth.gr
VICTORIA BILIOURIS 	AEM 2138 	vbiliouri@uth.gr
GERASIMOS SIDERIS 	AEM 2275 	gsideris@uth.gr

ΑΞΙΟΛΟΓΗΣΗ SJF ΑΛΓΟΡΙΘΜΟΥ

Μετά από την υλοποίηση του αλγορίθμου Shortest Job First με βάση το υποσχόμενο “ξέσπασμα” μιας διεργασίας και στη συνέχεια υλοποιώντας τον αλγόριθμο συνυπολογίζοντας και τον χρόνο αναμονής στην λίστα έτοιμων διεργασιών(ready-que) καταλήξαμε στο συμπέρασμα ότι η δεύτερη περίπτωση είναι και η πιο συμφέρουσα, δηλαδή με το μικρότερο μέσο χρόνο διεκπεραίωσης διεργασιών αφού οι διεργασίες τρέχουν με βάση το χρόνο που οι άλλες παραμένουν στην ουρά. Αυτό συμβαίνει διότι στην πρώτη περίπτωση, βάση του τρόπου που αρχικοποιουμε τα πεδία του struck  για το expected burst κάθε διεργασία που δημιουργείτε παίρνει τον επεξεργαστή με αποτέλεσμα η τελευταία να τρέχει μέχρι να τελειώσει και μετά οι υπόλοιπες ανεξάρτητα του χρόνου που περιμένουν στην ουρά προς εκτέλεση, ενώ παράλληλα δεν σημειώνονται αλλαγές στο expected  burst των διεργασιών που περιμένουν στην ουρά. Ακόμα η σειρά με την οποία θα τρέξουν οι διεργασίες επηρεάζετε μόνο από τον χρόνο που τρέχει μια διεργασία μέχρι να δημιουργηθεί η επόμενη διεργασία. Έτσι, όταν μια διεργασία λάβει τον CPU θα τον αφήσει μόνο όταν “πεθάνει” ή σε περίπτωση που μπει μια νέα διεργασία στην ουρά που θα χει expected burst = 0. Όσον αφορά την δεύτερη περίπτωση, πραγματοποιούνται συνεχείς αλλαγές διεργασιών στον CPU καθώς το goodness μιας διεργασίας που είναι το ζητούμενο σε αυτή την περίπτωση αλλάζει συνεχώς τιμή κι εξαρτάται από τις υπόλοιπες διεργασίες στην ready-que βάση του χρόνου που περιμένουν οι άλλες διεργασίες στην ουρά. Όσες περισσότερες διεργασίες υπάρχουν στην ουρά ο χρόνος αναμονής θα είναι μεγαλύτερος με αποτέλεσμα το goodness να μεγαλώνει αρκετά. 

Στο αρχείο test1 υπάρχουν μόνο NONINTERACTIVE διεργασίες. Δημιουργούμε 4 διεργασίες με διαφορετικούς χρόνους εκτέλεσης. Με βάση τους χρόνους που δημιουργούνται οι διεργασίες αυτές πρέπει να τρέχουν με την εξής σειρά λόγω του expected burst: πρώτα θα τελειώσει η task-4 γιατί δημιουργείτε τελευταία, μετα θα τρέξει μεχρι να τελειώσει η task-1  γιατί έχει το μικρότερο expected burst  αφού την πρώτη φορά έτρεξε μόνο 10 μονάδες χρόνου, έπειτα τρέχει η task-3 γιατί έχει το επόμενο μικρότερο expected burst γιατί έτρεξε 20 μονάδες χρόνου την πρώτη φορά και τέλος θα τρέξει η task-2 γιατί εχει το μεγαλύτερο expected burst αφου την πρώτη φορά έτρεξε για 30 μονάδες χρόνου.

Στο κώδικα με βάση το goodness το αρχείο test1  τρέχουν οι διεργασίες μέχρι να μπούν όλες και υπολογίζεται το goodness και όταν τρέχει η task4 επειδή η άλλες 3 με βάση τα στοιχεία έχουν ίδιο goodness θα τρέξει η task3 για 10 μονάδες χρόνου όπου αλλάζει το goodness και τρέχει η task2 για αλλά 10 και μετά τρέχει αυτή με το μικρότερο goodness που είναι η task1 που μετά τελειώνει. 

Στο αρχείο test2 αυξησαμε το χρόνο πρώτης εκτέλεσης της task-1 με αποτέλεσμα να τρέχουν: task-4  task-2  task-3  task-1.

Στο αρχείο test2 αυξησαμε το χρόνο πρώτης εκτέλεσης της task1 με αποτέλεσμα να αλλάξει τo goodness κάθεδιεργασιας άρα τρέχουνοι διεργασίες ως εξής: task-1,  task-2, task-3, task-4, task-3, task-2, task1 done, task-2 done, task-4 done, task-3 done.

Στο αρχείο test3 έχουμε μόνο διεργασίες INTERACTIVE. Δημιουργούμε 4 διεργασίες. Η τέταρτη που θα πάρει τον επεξεργαστή θα τρέξει μέχρι να σταματήσει και μετά τρέχουν με βάση το expected burst οι άλλες διεργασίες μέχρι να σταματήσουν. Όταν θα αρχίσουν πάλι αυτές τρέχουν με βάση το expected burst. Συνοπτικά, τρέχει η task1 μέχρι να έρθει η task2, όταν έρθει η task3 παίρνει τον επεξεργαστή μέχρι να έρθει η task4. Μετα από λίγο σταματάει η task4 και τρέχει η task-1 που είχε τρέξει λιγότερο την πρώτη φορά 10 μονάδες χρόνου. Όταν σταματήσει η task-1 τρέχει η task-3 που έτρεξε μόνο 20 μονάδες χρόνου και όταν σταματήσει η task-3 τρέχει η task-2. Με ανάλογο τρόπο τρέχουν και όταν αρχίσουν να τρέχουν πάλι. Με βάση τα στοιχεία των διεργασιων όσων αναφορά το goodness θα τρέξουν οι διεργασίες ως εξής task2, task4, task3.

Test3 - Η διάφορα σε σχέση με το προηγούμενο τρέξιμο είναι ότι οι διεργασίες αφού μπουν όλες η τελευταία τρέχει για 10 μονάδες χρόνου και μετά παίρνουν το επεξεργαστή με βάση το goodness όταν αρχίσουν να ξανατρεχουν.

Στο αρχειο test4 έχουμε 2 διεργασίες (NONINTERACTIVE: task-2, task-4) και 2 διεργασίες (INTERACTIVE: task-1, task-3). Σε αυτό το αρχείο δεν παρατηρούμε διάφορες καθώς καμία από τις INTERACTIVE διεργασίες δεν προλαβαίνουν να σταματησουν.

Στο αρχείο test5 έχουμε 2 διεργασίες (NONINTERACTIVE: task-1, task-2) και 2 διεργασίες (INTERACTIVE: task-3, task-4). Όπως και πριν με την σειρά που έρχονται οι διεργασίες θα παίρνουν το επεξεργαστή απλά η task-4 θα σταματήσει και θα δώσει τον επεξεργαστή στην επομενη διεργασία task-2 που έχει τρέξει λιγότερο επειδή αυτή είναι NONINTERACTIVE θα τελειώσει και μετά θα δώσει τον επεξεργαστή στην task-3 που ειχε το μικρότερο expected burst και θα τελειώσει χωρίς να σταματήσει . Μετά θα τρέξει η task-1 η οποία είναι NONINTERACTIVE και τέλος θα συνεχίσει η task-4 που δεν έχει το μεγαλύτερο expected burst.

Στο αρχείο test6 δημιουργούμε μια σειρά από διεργασίες παρόμοια με αυτή στο αρχείο complex με την διάφορα οτι τα παιδιά είναι INTERACTIVE.

Στο αρχείο test7 βλέπουμε το πρόβλημα του αλγόριθμου που ενώ οι διεργασίες task-2, task-3 έχουν λιγότερο χρόνο εκτέλεσης από της άλλες δεν θα τρέξουν ποτέ.

Σε παρόμοιο  αποτελέσμα έχουμε και Όταν τρέχουμε την goodness τρέξιμο μόνο που το ποια θα τρέξει εξαρτάται και από το χρόνο που έμεινε η διεργασια στην ουρά. Και οι διεργασίες εναλλασονται βάση της τιμής του goodness που έχει η κάθε διεργασια.

Ακόμα τρέχουμε  και τα ενδεικτικά αρχεία που υπήρχαν στην εργασία. Όταν τρέχουμε το  complex με τον expected burst η διεργασία πατέρας έχει το ιδιο expected burst time  με το NONINTERACTIVE παιδί οπότε δεν μπορεί να τελειώσει και μπαίνει σε loop. 

