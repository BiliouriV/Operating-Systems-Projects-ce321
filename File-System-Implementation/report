OPERATING SYSTEMS
4Η ΕΡΓΑΣΙΑ 
ΜΠΙΛΙΟΥΡΗ ΒΙΚΤΩΡΙΑ 2138, vbiliouri@inf.uth.gr
ΧΡΙΣΤΟΔΟΥΛΟΥ ΔΗΜΗΤΡΗΣ 2113, dchristodoulou@inf.uth.gr
ΣΙΔΕΡΗΣ ΓΕΡΑΣΙΜΟΣ 2275, gsideris@inf.uth.gr

FILE SYSTEM
Το  Filesystem που υλοποιήσαμε, χωρίζει τα αρχεία σε blocks δεδομένων μεγέθους 4KB,  τα οποία αποθηκεύονται σε directory εκτός του φακέλου που υπάρχουν τα αρχεία.  Σύμφωνα με τις παραδοχές της εκφώνησης, το filesystem απευθύνεται σε αρχεία μεγέθους μέχρι 64ΚΒ καθώς και σε μέγιστο αριθμό 10 αρχείων. Δεν ακολουθήσαμε την παραδοχή της εκφώνησης ότι τα αρχεία πρέπει να έχουν μέγεθος πολλαπλάσιο των 4KB, το filesystem λειτουργεί για αρχεία οποιουδήποτε μεγέθους (μέχρι 64ΚΒ).


EXPERIMENT
Έχουμε δημιουργήσει μέσα στο rootdir 5 καινούρια αρχεία πέραν του bogus.txt που δημιουργεί το makefile, και ένα directory που περιέχει 2 αρχεία. Μερικά από τα αρχεία μας έχουν κοινά στοιχεία με σκοπό να ελέγξουμε την σωστή δημιουργία το blocks, ότι δηλαδή δεν δημιουργούνται blocks με όμοια δεδομένα.
Το μέγεθος των αρχείων που φτιάξαμε είναι είτε πολλαπλάσιο των 4KB είτε όχι, διότι οι συναρτήσεις λειτουργούν για κάθε μέγεθος.
Το αρχείο aasseds αποτελείται από 3 blocks, το πρώτο block του οποίου είναι όμοιο με το πρώτο block του αρχείου dimitris.txt, το οποίο αποτελείται από 2 blocks. Επίσης το ίδιο block είναι παρόμοιο τα 1α blocks από τα αρχεία chr.txt (2 blocks συνολικά) και gerasimos.txt (εκ των οποίων 1o block είναι πανομοιότυπο). Ωστόσο επειδή έχουν μικρές διαφορές το hash είναι διαφορετικό και δημιουργούνται ξεχωριστά blocks. Το αρχείο vik.txt έχει σκουπίδια 4KB. Το αρχείο που βρίσκεται μέσα στο subdirectory test_folder , biliouri.txt δημιουργεί ένα block που είναι όμοιο με το 1o block toy chr.txt και gerasimos.txt. Τέλος υπάρχει και το αρχείο sid.txt το περιεχόμενο του οποίου διαφέρει από τα υπόλοιπα.
Block0.txt -> Trash
Aasseds.txt -> block1.txt, block2.txt, block3.txt
Bogus.txt -> block4.txt
Chr.txt -> block5.txt, block6.txt
Dimitris.txt -> block1.txt, block7.txt
Gerasimos.txt -> block5.txt
Vik.txt -> block8.txt
Test_folder
	Biliouri.txt -> block5.txt
	Sid.txt -> block9.txt
Άρα παρατηρούμε ότι ενώ κανονικά το σύνολο των blocks των αρχείων είναι 12 blocks, τα blocks που δημιουργούνται είναι 9 αφού μερικά αρχεία χρησιμοποιούν τα ίδια blocks. Έτσι η συνολική μνήμη της αποθήκης των blocks είναι μικρότερη από την μνήμη του φακέλου των αρχείων.
Τέλος όταν κάνουμε unmount το filesystem σβήνονται και όλα τα blocks.

FUNCTION
bb_open function:
Κάθε φορά που ανοίγουμε ένα αρχείο, αφού κάνουμε τον έλεγχο αν αυτό το αρχείο έχει ανοίξει ξανά (για να μην δημιουργηθούν τα blocks ξανά), αρχικά υπολογίζεται το μέγεθος του και ο αριθμός των blocks που θα δημιουργηθούν για αυτό, στοιχεία τα οποία αποθηκεύονται σε έναν πίνακα δύο διαστάσεων από structs file info (fd_table).  Ο πίνακας αυτός αποτελείται από  10 γραμμές ( πλήθος αρχείων που μπορούν να υπάρχουν στον φάκελο) και 17 στηλών (1 στήλη για το όνομα του αρχείου που ανοίγει και 16 στήλες που αποθηκεύεται το path των blocks που περιλαμβάνονται στο κάθε αρχείο). Ακόμη στην πρώτη στήλη του πίνακα αποθηκεύεται στο αντίστοιχο  πεδίο του struct, ο αριθμός των blocks που δημιουργούνται για κάθε αρχείο.
Στην συνέχεια,  χρησιμοποιώντας ένα for loop που τρέχει όσες φορές είναι ο αριθμός των blocks που έχει κάθε αρχείο,  αρχικοποιούμε το hash με ‘\0’,  διαβάζουμε από το κυρίως αρχείο 4ΚΒ δεδομένων,  και έπειτα υπολογίζουμε το hash των δεδομένων με την χρήση της συνάρτησης SHA1 από την βιβλιοθήκη openssl.  Επειδή όμως το hash που δημιουργείται είναι ένα string από μη εκτυπώσιμους χαρακτήρες, μετατρέπουμε το string αυτό σε αναγνώσιμο (hex_string) με την χρήση της sprintf.  Αυτό το string όπως και κάποιες άλλες πληροφορίες  σχετικές με τα blocks των αρχείων, αποθηκεύονται σε έναν μονοδιάστατο πίνακα από structs (block_memory).  Έτσι κάθε φορά που είναι να δημιουργηθεί ένα νέο block, ελέγχουμε αν αυτό το block υπάρχει ήδη, συγκρίνοντας το hash του με τα hashes των blocks που έχουμε ήδη δημιουργήσει.  Για να δημιουργηθεί ένα νέο block, τα hashes πρέπει να διαφέρουν επομένως το flag (found) να έχει την τιμή 0.
Έπειτα δημιουργούμε το καινούριο block και αποθηκεύουμε τις απαραίτητες πληροφορίες στα πεδία των structs.  Συγκεκριμένα, αποθηκεύουμε το path του καινούριου block τόσο στον πίνακα με τα blocks όσο και στον πίνακα με τα στοιχεία των αρχείων,  το όνομα του κάθε block,  και τέλος  έναν αριθμό που δηλώνει πόσες φορές  χρησιμοποιείται το κάθε block από τα αρχεία. 
Τέλος, οι global μεταβλητές  block_num  και file_num περιλαμβάνουν το πλήθος των blocks και των αρχείων που υπάρχουν στο σύστημα και χρησιμοποιούνται για την διάτρεξη των πινάκων κατά των έλεγχο ύπαρξης των αρχείων/ blocks.

bb_write function:
Για την υλοποίηση της write ακολουθήσαμε τα ίδια βήματα με την δημιουργία των blocks της open.  Αναλυτικότερα,  αν η προσθήκη των καινούριων δεδομένων γίνεται στο τέλος του αρχείου, υπολογίζουμε πόσα blocks αντιστοιχούν στο μέγεθος των δεδομένων, το hash του buf και ελέγχουμε αν υπάρχει  ήδη στοn πίνακα με τα blocks, αν ναι δεν δημιουργείται και αυξάνεται το πεδίο use και αποθηκεύουμε τις πληροφορίες του συγκεκριμένου block έτσι ώστε να μπορούμε τα το ανακτήσουμε,  αλλιώς δημιουργείται και συμπληρώνονται τα υπόλοιπα πεδία στους δύο πίνακες με όμοιο τρόπο όπως και στην open. Τέλος επιστρέφουμε τον αριθμό των bytes που γράφτηκαν στον buf.
Bb_read function:
Αρχικά διατρέχουμε τον πίνακα αρχείων που έχουμε δημιουργήσει, για να εντοπίσουμε την θέση του αρχείου που θέλουμε να διαβάσουμε, τον αριθμό και την θέση των blocks από τα οποία αποτελείται. Στην συνέχεια, με διάτρεξη του πίνακα αρχείων που περιλαμβάνει τα blocks, εντοπίζουμε τα ονόματα τους, τα ανοίγουμε και αποθηκεύουμε τα δεδομένα τους σε έναν μεγάλο buf, που θα περιλαμβάνει όλα τα δεδομένα του αρχείου.

bb_unlink function:
Σε αυτή την συνάρτηση βρίσκουμε το αρχείο που θέλουμε να διαγράψουμε, και από ποια blocks αποτελείται. Έπειτα αρχικοποιούμε τα πεδία που αναφέρονται σε αυτό το αρχείο σε ‘\0’. Αφού ψάξουμε αν τα blocks του αρχείου χρησιμοποιούνται και σε άλλα αρχεία, διαγράφουμε τα blocks που δεν πληρούν αυτή την προϋπόθεση, αλλιώς μειώνουμε τον αριθμό που μετράει το πλήθος των αρχείων που χρησιμοποιούν το ίδιο block.

bb_release function:
Εδώ ψάχνουμε το αρχείο που μας ενδιαφέρει στον πίνακα αρχείων, και μετά διατρέχουμε τον πίνακα αυτόν κατά στήλη για να δούμε από ποια blocks αποτελείται το αρχείο.  Αφού τα βρούμε ελέγχουμε αν είναι ανοιχτά και τα κλείνουμε.

bb_init function:
Κάνουμε αρχικοποίηση των global πινάκων από structs που χρησιμοποιούμε στις υπόλοιπες συναρτήσεις.

bb_destroy function:
Σε αυτή την συνάρτηση διατρέχουμε τον πίνακα με όλα τα blocks, ανακτούμε τα path τους και τα διαγράφουμε από την αποθήκη των blocks.

bb_getattr function:
Προσπαθήσαμε να την υλοποιήσουμε όμως επειδή χρησιμοποιείται πρωτού ανοίξουμε τα αρχεία και τα blocks δεν θέτει το απαραίτητο μέγεθος άρα και δεν μπορούμε να την χρησιμοποιήσουμε.
Οι συναρτήσεις bb_opendir και bb_readdir δεν τροποποιήθηκαν καθότι λειτουργούν επιθυμητά για την υλοποίηση μας.


Για την εκτέλεση του filesystem χρησιμοποιούμε το ενδεικτικό παράδειγμα που αναφέρεται στην εκφώνηση. Για να τρέξετε τον κώδικα πρέπει να αντικατασταθούν οι φάκελοι example  με τον experiments και ο scr με τον filesystem.

Στον φάκελο που περιεχονται οι δυο φάκελοι θα πρέπει να κάνουμε ./configure  μετά αλλάζουμε το makefile όπως αυτό είναι μέσα στον φάκελο filesystem και κανουμε make και μέσα στον φάκελο experiments εκτελουμε την εντολή  ../src/bbfs rootdir/ mountdir/ για να κάνουμε mount και στο τέλος την εντολη fusermount -u mountdir για να τερματισουμε το mount.




